<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Apollonian Window</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>

			// smothness of spheres
			const aw_renderHeight = 36;
			const aw_renderWidth = aw_renderHeight;
			const whirl = 90; //degrees cycled for color hue
			const group = new THREE.Group();
			const aw_maxiumBend = 1000000; // maximum bend for a recursively drawn pappus chain


			// Setting the Scene... 
			const scene = new THREE.Scene();
			//scene.background = 0xFFFFFF
			const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
			
			// Rendering the Renderer 
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			//Create our Matrix of "Circle" coordinates
			const M = new THREE.Matrix4();

			M.set(
			//	2, 1, 0, 0,
			//    3, 0, 2, 0,
 			//    6, 3, 4, 0,
 			    -1, 0, 0, 0,
 			    2, -1, 0, 0,
 			    2, 1, 0, 0,
 			    3, 0, 2, 0);

			//Boyd's Tranformations 
			const apollonianTransformA = new THREE.Matrix4();
			const apollonianTransformB = new THREE.Matrix4();
			const apollonianTransformC = new THREE.Matrix4();

			apollonianTransformA.set( 
				0, 0, 0, 1,
			    0, 1, 0, 0,
			    0, 0, 1, 0,
 			    -1, 2, 2, 2 );

			apollonianTransformB.set( 
				1, 0, 0, 0,
			    0, 0, 0, 1,
			    0, 0, 1, 0,
 			    2, -1, 2, 2 );

			apollonianTransformC.set( 
				1, 0, 0, 0,
			    0, 1, 0, 0,
			    0, 0, 0, 1,
 			    2, 2, -1, 2 );

			// Draws a sphere given 3D circle coordinates -- a (signed!) radius, and n^3 coordiantes to euclidean geometry for THREE.js
			function aw_drawSphere(aw_r, aw_x, aw_y, aw_z) {
				
				//const light = ((aw_x/aw_r)+(1/2))*100;
				//const saturation = ((aw_x/aw_r)+(1/2))*100;
				//const hue = Math.atan2((aw_z/aw_r),(aw_y/aw_r))*(180 / Math.PI);
	
				//const color6 = new THREE.Color("hsl(30, 50%, 50%)");
	
				const euclidean_geometry = new THREE.SphereGeometry(1/aw_r, aw_renderWidth, aw_renderHeight);
				const material = new THREE.MeshNormalMaterial( { transparent: true, opacity: .45 } );
				const sphere = new THREE.Mesh( euclidean_geometry, material );
	
		    	sphere.position.x = aw_x/aw_r;
		    	sphere.position.y = aw_y/aw_r;
		    	sphere.position.z = aw_z/aw_r;
				
				group.add(sphere);
	
		    	return sphere;
		  	}

		  	function aw_drawSpheresFromMatrix(m){

		  		const aw_A = aw_drawSphere(m.elements[0],m.elements[4],m.elements[8],m.elements[12]);
				const aw_B = aw_drawSphere(m.elements[1],m.elements[5],m.elements[9],m.elements[13]);
				const aw_C = aw_drawSphere(m.elements[2],m.elements[6],m.elements[10],m.elements[14]);
				const aw_D = aw_drawSphere(m.elements[3],m.elements[7],m.elements[11],m.elements[15]);
				//const aw_E = aw_drawSphere(14, 5, 12, 0);
			}
			
			function aw_TransformA(m){

				return(apollonianTransformA.multiply(m));
			}

			function aw_TransformB(m){

				return(apollonianTransformB.multiply(m));
			}

			function aw_TransformC(m){

				return(apollonianTransformC.multiply(m));
			}

			function aw_fillDisk(m){
	
				aw_drawSpheresFromMatrix(m);

				const A = aw_TransformA(m);
				const B = aw_TransformB(m);
				const C = aw_TransformC(m);

				aw_drawSpheresFromMatrix(A); //"in"
				aw_drawSpheresFromMatrix(B); //"out right"
				aw_drawSpheresFromMatrix(C); //"out left"
				//aw_drawSpheresFromMatrix(C.invert()); //"in"
				//aw_drawSpheresFromMatrix(B); //"out right"
				//aw_drawSpheresFromMatrix(C); //"out left"
	
				//aw_drawSpheresFromMatrix(aw_TransformA(A));
				//aw_drawSpheresFromMatrix(aw_TransformA(B));
				//aw_drawSpheresFromMatrix(aw_TransformA(C));
				//aw_drawSpheresFromMatrix(aw_TransformB(A));
				//aw_drawSpheresFromMatrix(aw_TransformB(B));
				//aw_drawSpheresFromMatrix(aw_TransformB(C));
				//aw_drawSpheresFromMatrix(aw_TransformC(A));
				//aw_drawSpheresFromMatrix(aw_TransformC(B));
				//aw_drawSpheresFromMatrix(aw_TransformC(C));
				//aw_drawSpheresFromMatrix(aw_TransformC(aw_TransformA(aw_TransformB(A))));
				//aw_drawSpheresFromMatrix(aw_TransformB(aw_TransformC(aw_TransformA(A))));
				//aw_drawSpheresFromMatrix(aw_TransformA(aw_TransformB(aw_TransformC(B))));
				//aw_drawSpheresFromMatrix(aw_TransformC(aw_TransformA(aw_TransformB(B))));
				//aw_drawSpheresFromMatrix(aw_TransformB(aw_TransformC(aw_TransformA(B))));
				//aw_drawSpheresFromMatrix(aw_TransformA(aw_TransformB(aw_TransformC(C))));
				//aw_drawSpheresFromMatrix(aw_TransformC(aw_TransformA(aw_TransformB(C))));
				//aw_drawSpheresFromMatrix(aw_TransformB(aw_TransformC(aw_TransformA(C))));
				//aw_drawSpheresFromMatrix(aw_TransformB(aw_TransformC(aw_TransformA(m))));
				//aw_drawSpheresFromMatrix(aw_TransformC(aw_TransformB(aw_TransformA(m))));
				//aw_drawSpheresFromMatrix(aw_TransformC(m));
				//aw_drawSpheresFromMatrix(B);
				//aw_drawSpheresFromMatrix(C);
				//aw_drawSpheresFromMatrix(aw_TransformA(A));
				//aw_drawSpheresFromMatrix(aw_TransformA(B));
				//aw_drawSpheresFromMatrix(aw_TransformA(C));
				//aw_drawSpheresFromMatrix(aw_TransformB(A));
				//aw_drawSpheresFromMatrix(aw_TransformB(B));
				//aw_drawSpheresFromMatrix(aw_TransformB(C));
				//aw_drawSpheresFromMatrix(aw_TransformC(A));
				//aw_drawSpheresFromMatrix(aw_TransformC(B));
				//aw_drawSpheresFromMatrix(aw_TransformC(C));
				
			}

			aw_fillDisk(M);
			
			
			scene.add( group ) 
			// Moving the Camera Out
			camera.position.z = 7;

			// Animating with framerate of the browser
			
			function animate() {
			requestAnimationFrame( animate );
			renderer.render( scene, camera );
			//group.rotation.x += 0.01;
			//group.rotation.y += 0.01;
			}
			
			animate();


		</script>
	</body>
</html>